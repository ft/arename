# vim:ft=perl
# example arename global hooks file

sub print_banner0 {
    # Yes, everything handed over to hooks (except for the namespace)
    # are references. This gives us simple two way communication, but
    # it's also a pretty big hammer. Think before screwing up. :)
    my ($namespace, $nameref, $verref, $confref, $methref, $suptagsref, $argvref) = @_;

    oprint "BANNER! $$nameref $$verref " . $argvref->[0] . "\n";

    # The following actually changes the $NAME variable, used
    # in ARename.pm, which doesn't hurt, because it is only the
    # name of the program running. For other hooks there might
    # be vital data in one of the references.
    # If you're not sure about your code debug it *first*.
    # -d (dry-run) is your friend!
    $$nameref =~ s/name/blame/;
}
register_hook('startup', \&print_banner0);

sub print_banner1 {
    my ($namespace, $nameref, $verref, $confref, $methref, $suptagsref, $argvref) = @_;

    # Since $NAME used to be 'arename', the substitution
    # in print_banner0() will have changed $NAME to 'areblame.pl',
    # which $$nameref below will reveal.
    oprint "ANOTHER BANNER! $$nameref $$verref\n";
}
register_hook('startup', \&print_banner1);

sub replace_spaces_by_underscore {
    # A simple way to post process generated file names, for
    # people who dislike whitespace in file names.
    my ($namespace, $templateref, $datref) = @_;

    $$templateref =~ s/\s+/_/g;
}
register_hook('post_expand_template', \&replace_spaces_by_underscore);

sub kill_nonascii {
    # When I tried to copy files (and arename can *copy* now, instead
    # of moving if you use -c or --copy) to my samsung Q1 audio player,
    # such copies failed when files contained certain characters. Like
    # u umlaut, or any other umlaut character for that matter So this
    # hook kills off all non-ascii characters by replacing them with an
    # underscore (which the most retarded of all filesystems should
    # groak...) - if you ask for it.
    #
    #   % arename -c -p /media/q1 -u killnonascii=yes *.mp3
    #
    # Problem solved - at least for me. :)
    my ($namespace, $templateref, $datref) = @_;

    return if (!get_opt("copymode"));
    return if (!defined user_get("killnonascii"));
    $$templateref =~ s/[^[:ascii:]]+/_/g;
}
register_hook('post_expand_template', \&kill_nonascii);

sub remove_empty_subdirs {
    # When arename renames files, it can be quite likely, that
    # due to the rename the directory a file was in previously will
    # become empty. arename itself will not remove such directories
    # and it will not in the future. If you want such house keeping,
    # you can achieve that by a hook, like this one.
    # Note, that this an example; there are probably better solutions.
    my ($namespace) = @_;
    my $file = get_file();
    my $dir = dirname($file);
    my $rc;

    do {
        return if ($dir eq '.');
        $rc = rmdir $dir;
        if ($rc) { oprint("removed empty dir: \"$dir\"\n"); }
        $dir = dirname($dir);

    } while ($rc);
}
register_hook('file_done', \&remove_empty_subdirs);

sub fix_template_albumless {
    # This hook was submitted by Maximilian Gaﬂ <mxey@cloudconnected.org>.
    # It applies another template, if arename could not read an album
    # tag in file, that is currently processed.
    #
    # ft: adding support user defined variable 'albumless_template'.
    # That way, you can do in your arenamerc file:
    #    set albumless_template = &artist/&tracknumber - &tracktitle
    # While '&artist/&tracktitle' remains the default, if you didn't.
    my($namespace, $templateref, $datref) = @_;

    unless($datref->{album}) {
        my $altemplate = user_get('albumless_template');

        $$templateref = defined $altemplate
                            ? $altemplate
                            : "&artist/&tracktitle";
    }
}
register_hook('pre_expand_template', \&fix_template_albumless);
