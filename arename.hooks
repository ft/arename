# vim:ft=perl
# example arename global hooks file

sub print_banner0 {
    # Yes, everything handed over to hooks (except for the namespace)
    # are references. This gives us simple two way communication, but
    # it's also a pretty big hammer. Think before screwing up. :)
    my ($namespace, $nameref, $verref, $confref, $suptagsref, $argvref) = @_;

    oprint "BANNER! $$nameref $$verref " . $argvref->[0] . "\n";

    # The following actually changes the $NAME variable, used
    # in ARename.pm, which doesn't hurt, because it is only the
    # name of the program running. For other hooks there might
    # be vital data in one of the references.
    # If you're not sure about your code debug it *first*.
    # -d (dry-run) is your friend!
    $$nameref =~ s/name/blame/;
}
register_hook('startup', \&print_banner0);

sub print_banner1 {
    my ($namespace, $nameref, $verref, $confref, $suptagsref, $argvref) = @_;

    # Since $NAME used to be 'arename', the substitution
    # in print_banner0() will have changed $NAME to 'areblame.pl',
    # which $$nameref below will reveal.
    oprint "ANOTHER BANNER! $$nameref $$verref\n";
}
register_hook('startup', \&print_banner1);

sub replace_spaces_by_underscore {
    # A simple way to post process generated file names, for
    # people who dislike whitespace in file names.
    my ($namespace, $templateref, $datref) = @_;

    $$templateref =~ s/\s+/_/g;
}
register_hook('post_expand_template', \&replace_spaces_by_underscore);

sub kill_nonascii {
    # When I tried to copy files (and arename can *copy* now, instead
    # of moving if you use -c or --copy) to my samsung Q1 audio player,
    # such copies failed when files contained certain characters. Like
    # u umlaut, or any other umlaut character for that matter So this
    # hook kills off all non-ascii characters by replacing them with an
    # underscore (which the most retarded of all filesystems should
    # groak...) - if you ask for it.
    #
    #   % arename -c -p /media/q1 -u killnonascii=yes *.mp3
    #
    # Problem solved - at least for me. :)
    my ($namespace, $templateref, $datref) = @_;

    return if (!get_opt("copymode"));
    return if (!defined user_get("killnonascii"));
    $$templateref =~ s/[^[:ascii:]]+/_/g;
}
register_hook('post_expand_template', \&kill_nonascii);

sub remove_empty_subdirs {
    # When arename renames files, it can be quite likely, that
    # due to the rename the directory a file was in previously will
    # become empty. arename itself will not remove such directories
    # and it will not in the future. If you want such house keeping,
    # you can achieve that by a hook, like this one.
    # Note, that this an example; there are probably better solutions.
    my ($namespace) = @_;
    my $file = get_file();
    my $dir = dirname($file);
    my $rc;

    do {
        return if ($dir eq '.');
        $rc = rmdir $dir;
        if ($rc) { oprint("removed empty dir: \"$dir\"\n"); }
        $dir = dirname($dir);

    } while ($rc);
}
register_hook('file_done', \&remove_empty_subdirs);

sub fix_template_albumless {
    # This hook was submitted by Maximilian Ga√ü <mxey@cloudconnected.org>.
    # It applies another template, if arename could not read an album
    # tag in the file, that is currently processed.
    #
    # ft: adding support user defined variable 'albumless_template'.
    # That way, you can do in your arenamerc file:
    #    set albumless_template = &artist/&tracknumber - &tracktitle
    # While '&artist/&tracktitle' remains the default, if you didn't.
    my ($namespace, $templateref, $datref) = @_;

    unless($datref->{album}) {
        my $altemplate = user_get('albumless_template');

        $$templateref = defined $altemplate
                            ? $altemplate
                            : "&artist/&tracktitle";
    }
}
register_hook('pre_expand_template', \&fix_template_albumless);

use Encode;
sub mp3_recode_iso_to_utf8 {
    # Tags in mp3s suck.
    # id3v2.2 uses iso encoding. 2.3 let's you use unicode, but just utf16.
    # 2.4 let's you use utf8 instead of -16 if you ask nicely. But nobody
    # really really supports 2.4.
    #
    # So, if you want your applications to work without mojibake, you probably
    # want to remain with using an iso encoding. (Unless your language really
    # doesn't work with iso at all - but in that case you probably know far
    # more about handling such problems than I will ever...) But if you are
    # on a recent-ish unix system and your default character encoding is
    # UTF-8 you probably don't want your filenames to be encoded differently.
    #
    # So, this is an example hooks that shows how one *could* tackle the
    # problem. Scan the tag strings for non-ascii data, assume iso encoding,
    # and recode to UTF-8.
    #
    # This can be done more clever, probably by guessing the encoding of the
    # source strings; but that's for someone else to tackle.
    my ($namespace, $rcref, $typeref, $rdref, $datref) = @_;
    my $name = 'mp3_recode_iso_to_utf8';
    my $src;

    return if ($$typeref ne 'mp3');
    foreach my $tag (keys %{ $datref }) {
        $src = $datref->{$tag};
        if ($src =~ m/[^[:ascii:]]/) {
            $datref->{$tag} = Encode::encode("UTF-8", $src);
            oprint_verbose("$name: * Recoded ($tag)\n");
            oprint_verbose("$name: * From: \"$src\"\n");
            oprint_verbose("$name: *   To: \"" . $datref->{$tag} . "\"\n");
        }
    }
}
register_hook('post_fill', \&mp3_recode_iso_to_utf8);
