#!/usr/bin/perl
use warnings;
use strict;
use ARename;

# documentation {{{
=pod

=head1 NAME

arename - automatically rename audio files by tagging information

=head1 SYNOPSIS

arename [OPTION(s)] FILE(s)...

=head1 OPTIONS AND ARGUMENTS

=over 8

=item B<-d>

Go into dryrun mode. This means, that no action will be taken. B<arename>
will print what it would do, if called without L<-d>.

=item B<-f>

Overwrite files if needed.

=item B<-h>

Display a short help text.

=item B<-H>

Do not make use of hooks of any sort (neither global nor local ones).

=item B<-L>

List the current configuration in the actual configuration format.

=item B<-l>

Read a local config file (./.arename.local). Overwrites the B<uselocalrc>
configuration setting.

=item B<-q>

Make the output way more quiet, when processing files.

This option conflicts with the verbose option.

=item B<-Q>

Be even more quiet (this option will suppress, if a file is skipped.
Except for files, that are skipped because they would overwrite something).

This option implies '-q'.

=item B<-s>

Read filenames from stdin after processing files given on the command line.
It reads one file name per line, which means that file names containing
newlines are not supported.

=item B<-V>

Display version information.

=item B<-v>

Enable verbose output.

=item B<-c> E<lt>fileE<gt>

Read I<file> instead of ~/.arenamerc.

=item B<-C> E<lt>fileE<gt>

Read I<file> B<after> ~/.arenamerc and B<before> ./.arename.local.

=item B<-p> E<lt>prefixE<gt>

Define a prefix for destination files.

=item B<-T> E<lt>templateE<gt>

Define a template, that will be used for files that contain a compilation
tag.

=item B<-t> E<lt>templateE<gt>

Define a generic template (for all files that do I<not> contain a
compilation tag).

=item I<FILE(s)...>

Input files, that are subject for renaming.

=back

=head1 DESCRIPTION

B<arename> is a tool that is able to rename audio files by looking at
a file's tagging information. It uses this information to assemble a
consistent destination file name. The user can define the format of the
destination filename by the use of template strings.

Templates can be defined in the L<Configuration Files|arename>, by the
I<template> and I<comp_template> (See L<SETTINGS|arename> below).

By default, B<arename> will refuse to overwrite destination files,
if the file in question already exists. You can force overwriting by
supplying the B<-f> option.

In order to see what would happen instead of actually modifying files, you
can use the B<-d> option. This way you can avoid problems, that would
occur if the situation (e.g. the information in the files or your
configuration) is not exactly as you expected it.

=head2 Supported file formats

B<arename> currently supports three widely used audio formats, namely
MPEG Layer3, ogg vorbis and flac (Free Lossless Audio Codec). The format,
that B<arename> will assume for each input file is determined by the file's
filename-extension (I<.mp3> vs. I<.ogg> vs. I<.flac>).
The extension check is case-insensitive.

I<.mp3> files may contain different types of tags, namely id3v1 and id3v2.
Id3v1 is a very limited format. Therefore B<arename> will use the id3v2 tag
when it finds it. Therefore you should make sure that the id3v2 tag has
all the information you need, if you use files with both id3v1 and id3v2
tags.

=head2 Inputting a *lot* of files

B<arename> can be used to keep the file names of whole audio archives in
sync. However, that means that you will have to tell the script the
location of many files, thousands maybe.

In order to do that you will face the problem, that on most UNIX-like
systems, the length of the argument list for external programs is limited
(recent Linux versions, as an exception, do not have that limitation
anymore).

So, even if your shell can do recursive globbing like ksh or zsh, this will
most likely get you into trouble (for more than just a few files):

  % arename -d **/*.mp3

There are ways to overcome that limitation, of course.

The first solution is to use B<find> in connection with B<arename>'s I<-s>
option:

  % find . -name "*.mp3" -print | arename -d -s

This will break for file names that contain newlines, because I<-s> will
read one file name per line from the standard input stream.

Another way of using B<find> to deal with this problem is to use find's
I<-exec> option:

  % find . -name "*.mp3" -exec arename -d '{}' '+'

This will work for every possible file name. No matter if it has spaces
or newlines in it. The I<+> at the end of the call causes find to call
the external program (B<arename> in this case) with as many arguments as
possible, without exceeding the limit. This requires a POSIXly correct
find. GNU find for instance, did not support the I<+> way for a long time.
If you are stuck with an old version, you can exchange the I<+> with a
I<;> (note, that a semicolon B<must> be quoted in any case), or use GNU's
xargs tool instead.

A last solution for zsh users would be zargs (which requires
'autoload zargs' in your zsh configuration):

  % zargs -- **/*.mp3 -- arename.pl -d

=head1 FILES

B<arename>'s behaviour can be altered by a number of files it reads when
starting up.

Normal configuration tasks are done in (how convenient)
L<Configuration Files|arename>, described below.

If you need more control, or want to solve special problems you are having,
you can do so by supplying Perl code in L<Hook definition files|arename>.

B<arename> can be configured to read configuration files as well as hook
definition files from the current working directory. This feature is
disabled by default, because they can be a security issue on multiuser
systems.

There are no such things as systems wide configuration files in B<arename>.

=head2 Configuration files

B<arename> uses up to three configuration files. As for most programs,
the script will try to read a configuration file, that is located in the
user's I<home directory>. In addition to that, it will try to load I<local>
configuration files, if it finds appropriately named files in the
I<current directory>.

=over 8

=item B<~/.arenamerc>

per-user global configuration file.

=item B<./.arename.local>

per-directory local configuration file (only read if I<uselocalrc> is set
or the I<-l> option is given on the command line).

=back

The per-user global configuration file can be substituted by another file,
if specified via the I<-c> option.

Last but not least, you can specify an intermediate configuration file,
that is read in between the global and the per-directory file, via the
I<-C> option.

=head3 File format

The format of the aforementioned files is pretty simple.
It is parsed line by line. Empty lines, lines only containing whitespace
and lines, whose first non whitespace character is a hash character (I<#>)
are ignored.

There are two different types of settings: boolean and scalar settings.

Booleans can be set like this:

  <setting> [true|false]

If the value is omitted, I<true> is assumed. I<true> and I<false> are read
case insensitively. And I<1> is synonymous to I<true>, as is I<0> to
I<false>.

Scalar settings are done very in a very similar way:

  <setting> <value>

If the value is omitted, string values will be set to an empty string and
numeric values will be set to zero.

In both cases, setting and value are separated by one or more whitespace
characters. The value will be the rest of the line (all of it, including
trailing whitespace).

If the value part start with a backslash, that backslash is left out of the
value. That makes it possible to define templates with leading whitespace.

If a line contains only a string within square brackets, that string is the
start of a section. Section names are matches for starts of file names.
That means, the following settings are will only applied for input file
names that start with the same string as the section name. Where file name
means the string, handed over to B<arename>. The string I<~/> at the
beginning of a section name is expanded to the user's home directory.

You may start as many sections as you would like.

A section named I</foo/bar/> supersedes a section named I</foo/> for a file
named I</foo/bar/baz.ogg>. So, the longest match wins.

One last possible configuration file entry is a user variable, which is
defined via the B<set> command. These settings are very different from the
normal settings. Therefore, they are defined in a different way. That way
is described in the L<User defined variables> subsection below.

=head2 Configuration file example

  # switch on verbosity
  verbose

  # canonicalize file names before working with them
  canonicalize

  # the author is crazy! use a sane template by default. :-)
  template &artist - &album (&year) - &tracknumber. &tracktitle

  # force files from /foo/bar/ to stay below that directory
  [/foo/bar/]
  prefix /foo/bar

=head2 Hook definition files

=over 4

=item B<~/.arename.hooks>

Defines global hooks, that are in effect in every directory if the I<usehooks>
option is set to B<true>.

=item B<./.arename.hooks.local>

This allows you to define special hooks, that will only be applied for processes
that run in the directory the local file is found (and if the I<uselocalhooks>
option is set to B<true>).

=back

For details about hooks in B<arename>, see L<HOOKS|arename> below.

=head1 SETTINGS

The following settings are supported in all configuration files:

=over 8

=item B<canonicalize>

If set, a given file name will be transformed to its cleaned up absolute
path. You may want to set this, if you are using sections in the
configuration. If you do not use sections, all this will give you is a
performance penalty. (default value: I<false>)

=item B<comp_template>

Defines a template to use with files that provide a compilation tag
(for 'various artist' CDs, for example). This setting can still be
overwritten by the B<-T> command line option. (default value:
I<va/&album/&tracknumber - &artist - &tracktitle>)

=item B<default_*>

default_artist, default_album, default_compilation, default_genre,
default_tracknumber, default_tracktitle, default_year

Defines a default value, for the given tag in files, that lack this
information. (default value: I<undefined>)

=item B<hookerrfatal>

If this is set to false, arename will continue execution even if
reading, parsing or compiling a hooks file failed. (default value:
I<false>)

=item B<prefix>

Defines a prefix for destination files. This setting can still be
overwritten by the B<-p> command line option. (default value: I<.>)

=item B<quiet>

Switches on quietness by default. (default value: I<off>)

=item B<quiet_skip>

Be quiet about skips by default. This implicitly sets 'quiet'.
(default value: I<off>)

=item B<sepreplace>

Tagging information strings may contain slashes, which is a pretty bad
idea on most filesystems. Therefore, you can define a string, that replaces
slashes with the value of this setting. (default value: I<_>)

=item B<template>

Defines a template to use with files that do not provide a compilation tag
(or where the compilation tag and the artist tag are exactly the same).
This setting can still be overwritten by the B<-T> command line option.
(default value: I<&artist[1]/&artist/&album/&tracknumber - &tracktitle>)

=item B<tnpad>

This defines the width, to which the tracknumber field is padded with zeros
on the left. (default value: I<2>)

=item B<usehooks>

If set to true use hooks defined in B<~/.arename.hooks>.
(default value: I<true>)

=item B<uselocalhooks>

If set to true use hooks defined in B<./.arename.hooks.local>.
(default value: I<false>)

=item B<uselocalrc>

If set to true, read a local configuration file (B<./.arename.local>),
if it exists. (default value: I<false>)

=item B<verbose>

Switches on verbosity by default. (default value: I<off>)

=back

=head2 User defined variables

You can use the B<set> command in arenamerc files. This way the user can
define his own variables. The namespace is seperate from B<arename's>
normal settings. (That means, you cannot, for example,  overwrite the
internal I<template> variable with this command.)

B<set> I<varname> = I<value>

There may be an arbitrary amount of whitespace around the equal sign
(including no whitespace at all). If you want to have a value that
starts in a whitespace character, you may start the value with a
backslash character (just like with the template settings, a leading
backslash is always ignored).

User defined variables are useful to make hooks configurable (see
L<HOOKS|arename> below).

=head1 TEMPLATE FORMAT

B<arename>'s templates are quite simple, yet powerful.

At simplest, a template is just a fixed character string. However, that would
not be exactly useful. So, the script is able to expand certain expressions
with information gathered from the file's tagging information.

The expressions can have two slightly different forms:

=over 8

=item B<&>I<identifier>

The simple form.

=item B<&>I<identifier>B<[>I<length>B<]>

The "complex" form. The I<length> argument in square brackets defines the
maximum length, to which the expression should be expanded.

That means, if the Artist of a file reveals to be 'I<Frank Zappa>', then
using 'B<&artist[1]>' will expand to 'I<F>'.

=back

=head2 Available expression identifiers

The data, that is expanded is derived from tagging information in
the audio files. For I<.ogg> and I<.flac> files, the tag checking
B<arename> does is case insensitive and the first matching tag
will be used.

=over 8

=item B<album>

Guess.

=item B<artist>

Guess again.

=item B<compilation>

For I<.ogg> and I<.flac> this is filled with information found in the
'albumartist' tag. For I<.mp3> this is filled with information from the
id3v2 TPE2 frame. If the mp3 file only provides a id3v1 tag, this is not
supported.

=item B<genre>

The genre or content type of the audio file.

=item B<tracknumber>

The number of the position of the track on the disc. Obviously. However, this
can be in the form of '12' or '12/23'. In the second form, only the part left
of the slash is used. The tracknumber is a little special, as you can define
to what width it should be padded with zeros on the left (see I<tnpad> setting
in L<SETTINGS|arename>).

=item B<tracktitle>

Well...

=item B<year>

Year (id3v1), TYER (id3v2) or DATE tag (.ogg/.flac).

=back

=head1 HOOKS

Before we start, a word of warning: Hooks can solve a lot of problems.
That amount of flexibility comes with its price. All data passed to
hook functions are B<references> to the B<actual data> in the script
(except for the namespace argument, which is a copy). If you write
hooks carelessly, arename will get back at you! HOOKS ARE A BIG
HAMMER, THAT CAN CRUSH PROBLEMS AS WELL AS LIMBS!

I<You have been warned!>

=head2 Discussion

The reason for implementing hooks was to have a simple way of post
processing tags, filenames etc. without having to invent own magic in
the configuration files, when Perl has regular expressions on steriods
anyway. Hooks can do more then pure pre and post processing, because
they are called in numerous places and give broad access to the script's
data structures. Still, post processing is probably the most useful
feature they implement.

Hooks are just Perl subroutines, which are defined in one of two files
(see L<FILES|arename>). They are run at certain events during the
execution of arename. The contents of the argument list for each hook
depends on what hook is called (see the list of hook events below).
However, the first argument (argument zero aka. $_[0]) to all hooks is
the namespace, the hook is called in.

The global hooks file is read before the local one, which means, that
this local file may overwrite and extend the definitions from the global
file, as much as Perl permits. This also means, that hooks from the
local file are run I<after> the ones from the global file (unless you
are using your own method of registering hooks; but if you do so, you
know what you are doing anyway).

Subroutines must be registered to arename, to be known as hooks.
Once registered, a subroutine can be removed from the known hooks,
if requested (see 'Utility subroutines' below).

The keys in various data hashes passed to the hooks can be one of
the following: I<album>, I<artist>, I<compilation>, I<genre>,
I<tracknumber>, I<tracktitle>, I<year>.

Hooks can also use the data from user defined variables, by using
their Perl interface (I<user_get>() and I<user_set>()):

  # Assume, the user set the myvar-variable to "bar"
  my $foo = user_get('myvar');    # $foo is now "bar"
  user_set('foo', "bar, baz");
  my $foo = user_get('myvar');    # $foo is now "bar, baz"

The currently processed file name can be accessed via two subroutines:
I<get_file()> and I<set_file()>. That way, you could even change the
file name of the processed file, while I<arename> works on it (which
you really should only do, if you know what you are doing).

=head2 Utility subroutines

There are two subroutines, that are used to tell arename about
subroutines, you defined that shall become hooks.

=over 4

=item B<register_hook>(I<event>, I<coderef>)

Registers a I<code reference> (read: your subroutine) for the given
I<event>. Example: register_hook('startup', \&custom_banner);

=item B<remove_hook>(I<event>, I<coderef>)

Removes B<all> entries of the I<code reference> for the given
I<event>. Example: remove_hook('startup', \&custom_banner);

If the coderef was added more than once, all entries are removed.

=back

=head2 List of hook events

=head3 Hooks in the main loop

These hooks are called at the highest level of the script.

=over 4

=item B<canonicalize>

This is called in the middle of the file name canonicalization process
(but B<only> it is enabled via the I<canonicalize> setting).

Get the current file name via I<get_file()>. The canonicalized file name
is handed to you via the hook's arguments. The value from this argument
will be assigned to the processed filename after the execution of this
hook.

I<Arguments>: B<1:> canonicalized file name

=item B<next_file_early>

Called at the start of the main loop I<before> any file checks are done.

I<Arguments>:

=item B<next_file_late>

Called in the main loop I<after> the file checks are done.

I<Arguments>:

=item B<file_done>

Called in the main loop I<after> the file has been processed.

I<Arguments>:

=item B<filetype_unknown>

Called in the main loop I<after> the file was tried to be processed but
the file type (the extension, specifically) was unknown.

I<Arguments>:

=back

=head3 Hooks in the renaming procedure

When all data has been gathered, arename will go on to actually
rename the files to their new destination name (which will be generated
in the process, see L<Hooks when expanding the template> below).

=over 4

=item B<pre_apply_defaults>

This is the first action to be taken in the renaming process. It is
called even before the default values are applied.

I<Arguments>: B<1:> data hash, B<2:> file extension

=item B<pre_template>

Called I<before> template expansions have been done.

I<Arguments>: B<1:> data hash, B<2:> file extension

=item B<post_template>

Called I<after> the template has been expanded and the new file name
has been completely generated (including the destination directory
prefix).

I<Arguments>: B<1:> data hash, B<2:> file extension
B<4:> the generated new filename (including directory prefix and file
extension)

=item B<post_ensure_dir>

The destnation directory for the new file name may contain sub directories,
which currently do not exist. This hook is called I<after> it is ensured,
every directory portion exists.

I<Arguments>: B<1:> data hash, B<2:> file extension
B<4:> the generated new filename (including directory prefix and file
extension)

=item B<post_rename>

This is the final hook in the actual renaming process. The file has been
renamed at this point.

I<Arguments>: B<1:> data hash, B<2:> file extension
B<4:> the generated new filename (including directory prefix and file
extension)

=back

=head3 Hooks when expanding the template

These hooks are called when the template string is filled with the data
from tags in the audio files. All file type specific actions will have
been taken care of already. That makes these hooks probably most useful
for post processing tags, the template and file names.

=over 4

=item B<pre_expand_template>

Called before any expansions are done.

I<Arguments>: B<1:> the template string, B<2:> the data hash

=item B<expand_template_next_tag>

This hook is triggered when the next identifier in the template string
is processed. At this point it is already verified, that there is an
according tag in the data hash to fill in the identifier's space.

I<Arguments>: B<1:> the template string, B<2:> the tag's name
B<3:> the value of the length modifier in the template (zero, if
unspecified) B<4:> the data hash

=item B<expand_template_postprocess_tag>

This hooks is triggered after all internal processing of the replacement
token is done (directory seperators are replaced; tracknumbers are padded
up).

I<Arguments>: B<1:> the template string, B<2:> the text token, that will
replace the identifier in the template, B<3:> the tag's name B<4:> the
value of the length modifier, B<5:> the data hash

=item B<post_expand_template>

Called after all expansions have been done, right before the the resulting
string is returned.

I<Arguments>: B<1:> the template string, B<2:> the data hash

=back

=head3 Hooks when gathering information

These hooks are triggered while the tag information is extracted from
the audio files arename is processing. Due to the differing nature
of the the involved backends, these are slightly different from file type
to file type.

Specifically, the tag for .ogg and .flac files are read one after another
(the tags in these files are pretty much the same, hence they are processed
exactly the same), whereas tags in .mp3 files are read all at the same
time.

=over 4

=item B<pre_process_flac>

I<.flac only!>

Called I<before> a flac file is processed.

I<Arguments>:

=item B<post_process_flac>

I<.flac only!>

Called I<after> a flac file is processed.

I<Arguments>:

=item B<pre_process_ogg>

I<.ogg only!>

Called I<before> an ogg file is processed.

I<Arguments>:

=item B<post_process_ogg>

I<.ogg only!>

Called I<after> an ogg file is processed.

I<Arguments>:

=item B<pre_handle_vorbistag>

I<.ogg and .flac only!>

Triggered I<before> any processing of a certain tag. It is not ensured
that the tag is even among the supported tags at this point.

I<Arguments>: B<1:> tag name, B<2:> tag value, B<3:> data hash

=item B<pre_handle_vorbistag>

I<.ogg and .flac only!>

Triggered I<after> a certain tag was processed.

I<Arguments>: B<1:> tag name, B<2:> tag value, B<3:> the internal name for
the tag (also used as the key in the data hash), B<4:> data hash

=item B<pre_process_mp3>

I<.mp3 only!>

Called I<before> an mp3 file is processed.

I<Arguments>:

=item B<post_process_mp3>

I<.mp3 only!>

Called I<after> an mp3 file is processed.

I<Arguments>:

=item B<pre_handle_mp3tag>

I<.mp3 only!>

Called I<before> data from the mp3 object is copied to the data hash.

I<Arguments>: B<1:> the mp3 object, B<2:> data hash

=item B<post_handle_mp3tag>

I<.mp3 only!>

Called I<after> data from the mp3 object has been copied to the data hash.

I<Arguments>: B<1:> the mp3 object, B<2:> data hash

=back

=head3 Miscellaneous hooks

=over 4

=item B<apply_defaults>

This is triggered before values from the default_* settings are applied
to missing values in the audio file. This hook is I<only> run if the
default value for a tag will be used!

I<Arguments>: B<1:> data hash, B<2:> defaults hash, B<3:> current key

=item B<pre_method>

This hook is called after a method for a file type is choosen but
I<before> the method was executed.

I<Arguments>: B<1:> method name

=item B<post_method>

Called after a method for a file type was executed.

I<Arguments>: B<1:> method name

=item B<startup>

Called directly after all the module initialisation is done, at the very
start of the script. Configuration files will have been read, as well as
hook files (obviously) and command line options will have been handled at
this point already.

This hook may be useful for postprocessing the configuration as well as
for debugging.

I<Arguments>: B<1:> program name, B<2:> its version, B<3:> configuration
hash, B<4:> hash of extensions, that point the the according method for
the file type B<5:> array of supported tags, B<6:> the program's argument
list

=item B<normal_quit>

Called at the end of the script. This is reached if nothing fatal happened.

I<Arguments>: B<1:> the program's argument list

=back

=head2 Example

This is a very simple example for a hook file, that prints a custom
banner and replaces all whitespace in the expanded template with
underscores:

  sub my_banner { oprint "Hello World.\n"; }
  sub replace_spaces_by_underscore {
      my ($templateref, $datref) = @_;
      $$templateref =~ s/\s+/_/g;
  }
  register_hook('startup', \&my_banner);
  register_hook('post_expand_template',
      \&replace_spaces_by_underscore);

Further examples can be found in the arename.hook file of the
distribution.

=head1 SEE ALSO

L<Ogg::Vorbis::Header>, L<Audio::FLAC::Header> and L<MP3::Tag>.

=head1 AUTHOR

Frank Terbeck E<lt>ft@bewatermyfriend.orgE<gt>,

Please report bugs.

=head1 LICENCE

 Copyright 2007, 2008
 Frank Terbeck <ft@bewatermyfriend.org>, All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:

   1. Redistributions of source code must retain the above
      copyright notice, this list of conditions and the following
      disclaimer.
   2. Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials
      provided with the distribution.

  THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS OF THE
  PROJECT BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=cut

#}}}

my ( $NAME, $VERSION ) = ( 'arename', '@@arenameversioninfo@@' );

# Initialisation {{{

ARename::set_nameversion($NAME, $VERSION);
ARename::set_default_options();
ARename::read_cmdline_options();
ARename::read_rcs();

if (ARename::cmdopts('L')) {
    ARename::dump_config();
    exit 0;
}

ARename::read_hook_files();
ARename::set_default_methods();
ARename::startup_hook();

#}}}
# customisation and cosmetics {{{

sub dvr_newline {
    if (   ARename::get_opt("dryrun")
        || ARename::get_opt("readstdin")
        || ARename::get_opt("verbose")) {
        print "\n";
    }
}

# clear the line prefix, if we're running quietly.
if (ARename::get_opt("quiet")) {
    ARename::set_opt("oprefix", "");
}

dvr_newline();

if (ARename::get_opt("dryrun")) {
    print "+++ We are on a dry run!\n";
}

if (ARename::get_opt("verbose")) {
    print "+++ Running verbosely.\n";
}

if (ARename::get_opt("readstdin")) {
    print "+++ Reading stdin for filenames (after \@ARGV).\n";
}

dvr_newline();

# }}}

foreach my $file (@ARGV) {
    ARename::process_file($file);
}

if (ARename::get_opt("readstdin")) {
    while (<STDIN>) {
        chomp;
        ARename::process_file($_);
    }
}

ARename::run_hook('normal_quit', \@ARGV);
